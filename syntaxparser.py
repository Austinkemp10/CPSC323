#####################################################################
##            CPSC323 Assignment 3                                 ##
##            Team Members:                                        ##
##                          1. Aishwarya Iyer                      ##
##                          2. Abhishek Mhatre                     ##
##                                                                 ##
#####################################################################



import lexer
from Stack import Stack

# Initial address
memory_address = 2000

Jump_Stack = Stack()

# Input filename
input_filename = ''

Instruction_Table_Address_Array = []
Instruction_Table_Operation_Array = []
Instruction_Table_Operand_Array = []
# Instruction table address starts with 0
instruction_table_address = 0

Identifier_Array = []
Memory_Address_Array = []
TypeArray = []


# Function to terminate the program
def terminate():
    exit()


# Function to check whether the Identifier already exist in the Symbol Table.
def lookup():
    pass


# Function to insert Identifiers into the Symbol Table.
def insert():
    pass


# Function to list (display) Symbol Tables (list of Identifiers).
def list():
    pass


# Purpose: change the address of an  operand
def back_patch(jump_address):
    global Instruction_Table_Address_Array
    address = Jump_Stack.pop()
    Instruction_Table_Operand_Array[address] = jump_address + 1


# Function to create Symbol Table
def create_symbol_table(input_filename):
    global Identifier_Array, Memory_Address_Array, TypeArray, memory_address

    # Read lexer output file generated by lexer.py
    lexer_output_file = open(input_filename + "_lexer_output" + ".txt", "r")
    lexer_table = lexer_output_file.readlines()
    output_file = open(input_filename + "_symbol_table" + ".txt", "w")

    i = 2
    while i < len(lexer_table) - 1:

        line_number, token, lexeme, i = next_lexeme(lexer_table, i)
        if (lexeme == "int") or (lexeme == "boolean"):
            tempType = lexeme
            line_number, token, lexeme, i = next_lexeme(lexer_table, i)
            while (lexeme != ";"):
                line_number, token, lexeme, i = next_lexeme(lexer_table, i)
                if (lexeme == ",") or (lexeme == ";") or (lexeme == tempType):
                    i += 1
                else:
                    if (lexeme in Identifier_Array):
                        print(lexeme + " has already been declared")
                        terminate()
                    else:
                        Identifier_Array.append(lexeme)
                        Memory_Address_Array.append(memory_address)
                        memory_address += 1
                        TypeArray.append(tempType)
                        i += 1

        elif (token == "Identifier"):
            if (lexeme not in Identifier_Array):
                error_string = "[Line Number:" + line_number + "]=" + lexeme + " not declared\n"
                print(error_string)
                output_file.write(error_string)
                print("Program terminated")
                terminate()
            else:
                i += 1
        elif (lexeme == "real"):
            error_string = "[Line Number:" + line_number + "]=" + "No \'real\' type is allowed.\n"
            print(error_string)
            output_file.write(error_string)
            print("Program terminated")
            terminate()
        else:
            i += 1

    index = 0
    output_file.write("IDENTIFIER\t\t\t\tMEMORY LOCATION\t\t\t\tTYPE\n")
    while index < len(Identifier_Array):
        output_file.write(
            Identifier_Array[index] + "\t\t\t\t\t\t\t" + str(Memory_Address_Array[index]) + "\t\t\t\t\t" + TypeArray[
                index] + "\n")
        index += 1


# End of create_symbol_table() function

# Function to print assembly code
def print_assembly_code():
    assembly_output_file = open(input_filename + "_assembly_code" + ".txt", "w")

    i = 0
    while i < len(Instruction_Table_Address_Array):
        if Instruction_Table_Operand_Array[i] == None:
            assembly_output_file.write(
                str(Instruction_Table_Address_Array[i] + 1) + ". " + Instruction_Table_Operation_Array[i] + '\n')
        else:
            assembly_output_file.write(
                str(Instruction_Table_Address_Array[i] + 1) + ". " + Instruction_Table_Operation_Array[i] + " " + str(
                    Instruction_Table_Operand_Array[i]) + '\n')
        i += 1


# End of print_assembly_code() function


# Function to generate assembly code instruction
def generate_assembly_instruction(operation_instr, operation):
    global Instruction_Table_Address_Array, Instruction_Table_Operation_Array, Instruction_Table_Operand_Array, instruction_table_address

    Instruction_Table_Address_Array.append(instruction_table_address)
    Instruction_Table_Operation_Array.append(operation_instr)
    Instruction_Table_Operand_Array.append(operation)

    instruction_table_address += 1


# Function to get the memory address of the variable if it is already present in the Symbol table
def get_memory_address(save):
    identifierPosition = 0
    if save in Identifier_Array:
        identifierPosition = Identifier_Array.index(save)

    return Memory_Address_Array[identifierPosition]


# Function to get the next lexeme & token from the lexer output table
def next_lexeme(lexer_table, i):
    j = -1
    token = ""
    lexeme = ""
    line_number = ""

    if (i < len(lexer_table)):
        while j < len(lexer_table[i]):
            while (True):
                j += 1
                if line_number == "":
                    if lexer_table[i][j] == "" or lexer_table[i][j] == "\t":
                        continue
                    elif lexer_table[i][j].isdigit():
                        line_number += str(lexer_table[i][j])
                else:
                    if lexer_table[i][j] == " " or lexer_table[i][j] == "\t":
                        break
                    else:
                        line_number += lexer_table[i][j]

            while (True):
                j += 1
                if token == "":
                    if lexer_table[i][j] == " " or lexer_table[i][j] == "\t":
                        continue
                    elif lexer_table[i][j].isalpha():
                        token += lexer_table[i][j]
                else:
                    if lexer_table[i][j] == " " or lexer_table[i][j] == "\t":
                        break
                    else:
                        token += lexer_table[i][j]

            while (True):
                j += 1
                if lexer_table[i][j] == " " or lexer_table[i][j] == "\t":
                    continue
                elif lexer_table[i][j] == "\n":
                    break
                else:
                    lexeme += lexer_table[i][j]
            break

        return line_number, token, lexeme, i
    else:
        print('\n\n*****    Parsing finished    *****')
        # Print Assembly Code
        print_assembly_code()
        terminate()
# End of next_lexeme() function


# Main grammar starts here
def simplified_RAT18S(lexer_table_content):
    global input_filename

    syntactic_correct = False

    # Output file
    output_file = open(input_filename + "_syntax_output" + ".txt", "w")

    # Print Symbol Table
    create_symbol_table(input_filename)

    # first two lines of the lexer output table are heading
    # therefore i starts from 2
    i = 2

    while i < (len(lexer_table_content) - 1):
        # token = ""
        # lexeme = ""
        # line_number = ""

        # Get first lexeme and token from the lexer output table
        line_number, token, lexeme, i = next_lexeme(lexer_table_content, i)

        # R1. <Rat18S>  ::=   <Opt Function Definitions>   %%  <Opt Declaration List>  <Statement List>
        # print ("Token: " + token + " --- Lexeme: " + lexeme)
        # output_file.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        # syntactic_correct, i = OptFunctionDefinitions(lexer_table, i, lexeme, token, output_file)

        # if (i < len(lexer_table) - 1):
        # line_number, token, lexeme, i = next_lexeme(lexer_table, i)
        if (lexeme == "%%"):
            i += 1
            print("Token: " + token + " --- Lexeme: " + lexeme)
            output_file.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            syntactic_correct, i = OptDeclarationList(lexer_table_content, i, lexeme, token, output_file)
            syntactic_correct, i = StatementList(lexer_table_content, i, lexeme, token, output_file)
        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing %% at the start of <Opt Declaration List>\n"
            print(error_string)
            output_file.write(error_string)
            print("Program terminated")
            terminate()
# End of R1
# End of RAT18S


# Function for R2. <Opt Function Definitions> ::= <Function Definitions>     |  <Empty>
# def OptFunctionDefinitions(lexer_table, i, lexeme, token, outputFile):
#     syntactic_correct = False
#     line_number, token, lexeme, i = next_lexeme(lexer_table, i)
#     if (lexeme == "function"):
#         line_number, token, lexeme, i = next_lexeme(lexer_table, i)
#         print ("Token: " + token + " --- Lexeme: " + lexeme)
#         outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
#         print ("     <Opt Function Definitions> ::= <FunctionDefinitions>\n")
#         outputFile.write("     <Opt Function Definitions> ::= <FunctionDefinitions>\n")
#         syntactic_correct, i = FunctionDefinitions(lexer_table, i, lexeme, token, outputFile)
#
#     else:
#         print ("Token: " + token + " --- Lexeme: " + lexeme)
#         outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
#         print ("     <Opt Function Definitions> ::= <Empty>\n")
#         outputFile.write("     <Opt Function Definitions> ::= <Empty>\n")
#         syntactic_correct, i = Empty(lexer_table, i, lexeme, token, outputFile)
#
#     return syntactic_correct, i


# End of OptFunctionDefinitions


# Function for R3. <Function Definitions>  ::= <Function> <Function Definitions Prime>
# def FunctionDefinitions(lexer_table, i, lexeme, token, outputFile):
#     syntactic_correct = False
#     print ("     <Function Definitions> ::= <Function><Function Definitions Prime>\n")
#     outputFile.write("     <Function Definitions> ::= <Function><Function Definitions Prime>\n")
#     syntactic_correct, i = Function(lexer_table, i, lexeme, token, outputFile)
#     syntactic_correct, i = FunctionDefinitionsPrime(lexer_table, i, lexeme, token, outputFile)
#     print ("     <Function Definitions> ::= <Function>\n")
#     outputFile.write("     <Function Definitions> ::= <Function>\n")
#
#     return syntactic_correct, i


# End of FunctionDefinitions

# Function for R4.<Function Definitions Prime>  ::= <Function Definitions> | Epsilon
# def FunctionDefinitionsPrime(lexer_table, i, lexeme, token, outputFile):
#     syntactic_correct = False
#     line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
#     print ("Token: " + token + " --- Lexeme: " + lexeme)
#     outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
#     if (lexeme == "%%"):
#         print ("     <Function Definitions Prime> ::= Epsilon")
#         outputFile.write("     <Function Definitions Prime> ::= Epsilon\n")
#         syntactic_correct = True
#
#     elif (lexeme == "function"):
#         print ("     <Function Definitions Prime> ::= <Function Definitions>\n")
#         outputFile.write("     <Function Definitions Prime> ::= <Function Definitions>\n")
#         syntactic_correct, i = FunctionDefinitions(lexer_table, i, lexeme, token, outputFile)
#
#     else:
#         error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Invalid token.\n"
#         print (error_string)
#         outputFile.write(error_string)
#         print("Program terminated")
#         terminate()
#
#     return syntactic_correct, i
#

# End of FunctionDefinitionsPrime


# Function for R5.<Function> ::= function  <Identifier>  [ <Opt Parameter List> ]  <Opt Declaration List>  <Body>
def Function(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    print("     <Function> ::= function <Identifier> [ <Opt Parameter List> ] <Opt Declaration List> <Body>\n")

    if (lexeme == "function"):
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        if (token == "Identifier"):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            print("     <Function> ::= function <Identifier> [ <Opt Parameter List> ] <Opt Declaration List> <Body>\n")
            line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

            if (lexeme == "["):
                print("Token: " + token + " --- Lexeme: " + lexeme)
                outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                syntactic_correct, i = OptParameterList(lexer_table, i, lexeme, token, outputFile)
                line_number, token, lexeme, i = next_lexeme(lexer_table, i)

                if (lexeme == "]"):
                    print("Token: " + token + " --- Lexeme: " + lexeme)
                    outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
                    syntactic_correct, i = OptDeclarationList(lexer_table, i, lexeme, token, outputFile)
                    syntactic_correct, i = Body(lexer_table, i, lexeme, token, outputFile)

                else:
                    error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ']'.\n"
                    print(error_string)
                    outputFile.write(error_string)
                    print("Program terminated")
                    terminate()

            else:
                error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '['.\n"
                print(error_string)
                outputFile.write(error_string)
                print("Program terminated")
                terminate()

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing Identifier.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()
    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing 'function'.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Function()

# Function for R6.<Opt Parameter List> ::=  <Parameter List>    |     <Empty>
def OptParameterList(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (lexeme != "]"):
        i -= 1
        print("     <Opt Parameter List> ::= <Parameter List>\n")
        outputFile.write("     <Opt Parameter List> ::= <Parameter List>\n")
        syntactic_correct, i = ParameterList(lexer_table, i, lexeme, token, outputFile)

    elif (lexeme == "]"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Opt Parameter List> ::= <Empty>\n")
        outputFile.write("     <Opt Parameter List> ::= <Empty>\n")
        syntactic_correct, i = Empty(lexer_table, i, lexeme, token, outputFile)

    return syntactic_correct, i
# End of OptParameterList()

# Function for R7.<Parameter List>  ::=  <Parameter> , <Parameter List Prime>
def ParameterList(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    print("     <Parameter List> ::= <Parameter> , <Parameter List Prime>\n")
    outputFile.write("     <Parameter List> ::= <Parameter> , <Parameter List Prime>\n")

    syntactic_correct, i = Parameter(lexer_table, i, lexeme, token, outputFile)
    syntactic_correct, i = ParameterListPrime(lexer_table, i, lexeme, token, outputFile)

    return syntactic_correct, i
# End of ParameterList()

# Function for R8.<Parameter List Prime>  ::= <Parameter> | Epsilon
def ParameterListPrime(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

    if (lexeme == ","):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Parameter List Prime> ::= ,<Parameter List>\n")
        outputFile.write("     <Parameter List Prime> ::= ,<Parameter List>\n")
        syntactic_correct, i = ParameterList(lexer_table, i, lexeme, token, outputFile)

    else:
        print("     <Parameter List Prime> ::= Epsilon")
        outputFile.write("     <Parameter List Prime> ::= Epsilon\n")
        syntactic_correct = True

    return syntactic_correct, i
# End of ParameterListPrime()

# Function for R9.<Parameter>  ::= <IDs> : <Qualifier>
def Parameter(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    print("     <Parameter> ::= <IDS> := <Qualifier>\n")
    outputFile.write("     <Parameter> ::= <IDS> := <Qualifier>\n")

    syntactic_correct, i = IDs(lexer_table, i, lexeme, token, outputFile)
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

    if (lexeme == ":"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        syntactic_correct, i = Qualifier(lexer_table, i, lexeme, token, outputFile)

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing Identifier.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Parameter()

# Function for R10. <Qualifier> ::= int     |    boolean    |  real
def Qualifier(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

    if (lexeme == "int") or (lexeme == "boolean") or (lexeme == "real"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Qualifier> ::= " + lexeme)
        outputFile.write("     <Qualifier> ::= " + lexeme + "\n")
        syntactic_correct = True

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing Qualifier.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Qualifier()

# Function for R11.<Body>  ::=  {  < Statement List>  }
def Body(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

    if (lexeme == "{"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        syntactic_correct, i = StatementList(lexer_table, i, lexeme, token, outputFile)
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
        if (lexeme == "}"):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            print("     <Body> ::= {<Statement List>}")
            outputFile.write("     <Body> ::= {<Statement List>}\n")

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '}'.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '{'.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Body

# Function for R12.<Opt Declaration List> ::= <Declaration List>   |    <Empty>
def OptDeclarationList(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i)
    if (lexeme == "int") or (lexeme == "boolean") or (lexeme == "real"):
        print("     <OptDeclarationList> ::= <DeclarationList>")
        outputFile.write("     <OptDeclarationList> ::= <DeclarationList>\n")
        i -= 1
        syntactic_correct, i = DeclarationList(lexer_table, i, lexeme, token, outputFile)

    else:
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <OptDeclarationList> ::= Epsilon")
        outputFile.write("     <OptDeclarationList> ::= <Empty>\n")
        syntactic_correct, i = Empty(lexer_table, i, lexeme, token, outputFile)

    return syntactic_correct, i - 1
# End of OptDeclarationList


# Function for R13.<Declaration List> ::= <Declaration> <Declaration List Prime>
def DeclarationList(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    print("     <DeclarationList> ::= <Declaration>;<DeclarationLineNumbeLrist>\n")
    outputFile.write("     <DeclarationList> ::= <Declaration>;<DeclarationList>\n")

    syntactic_correct, i = Declaration(lexer_table, i, lexeme, token, outputFile)
    syntactic_correct, i = DeclarationListPrime(lexer_table, i, lexeme, token, outputFile)

    return syntactic_correct, i
# End of DeclarationList()


# Function for R14.<Declaration List Prime> ::= <Declaration List> ! Epsilon
def DeclarationListPrime(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (lexeme == "real") or (lexeme == "integer") or (lexeme == "boolean"):
        print("     <Declaration List Prime> ::= ;<Declaration List>\n")
        outputFile.write("     <Declaration List Prime> ::= ;<Declaration List>\n")
        i -= 1
        syntactic_correct, i = DeclarationList(lexer_table, i, lexeme, token, outputFile)

    else:
        print("     <Declaration List Prime> ::= Epsilon")
        outputFile.write("     <Declaration List Prime> ::= Epsilon\n")
        syntactic_correct = True

    return syntactic_correct, i
# End of DeclarationListPrime()

# Function for R15. <Declaration> ::=   <Qualifier > <IDs>
def Declaration(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    print("     <Declaration> ::= <Qualifier> <IDs>\n")
    outputFile.write("     <Declaration> ::= <Qualifier> <IDs>\n")

    syntactic_correct, i = Qualifier(lexer_table, i, lexeme, token, outputFile)
    syntactic_correct, i = IDs(lexer_table, i, lexeme, token, outputFile)
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (lexeme == ";"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        return syntactic_correct, i

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ';'.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()
# End of Declaration

# Function for R16.<IDs> ::=     <Identifier>    | <Identifier>, <IDs>
def IDs(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (token == "Identifier"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <IDs> ::= <Identifier>")
        outputFile.write("     <IDs> ::= <Identifier>\n")
        syntactic_correct, i = IDsPrime(lexer_table, i, lexeme, token, outputFile)

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing Identifier.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of IDs()


# Function for R17.<IDs> ::=     <IDs>    | Epsilon
def IDsPrime(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (lexeme == ","):
        print("     <IDs Prime> ::= ,<IDs>\n")
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        syntactic_correct, i = IDs(lexer_table, i, lexeme, token, outputFile)

    else:
        print("     <IDsPrime> ::= Epsilon")
        outputFile.write("     <IDsPrime> ::= Epsilon\n")
        syntactic_correct = True
        i -= 1

    return syntactic_correct, i
# End of IDsPrime()


# Function for R18.<Statement List> ::=   <Statement> <Statement List Prime>
def StatementList(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    print("     <Statement List> ::= <Statement> <Statement List Prime>")
    outputFile.write("     <Statement List> ::= <Statement> <Statement List Prime>\n")

    syntactic_correct, i = Statement(lexer_table, i, lexeme, token, outputFile)
    syntactic_correct, i = StatementListPrime(lexer_table, i, lexeme, token, outputFile)

    return syntactic_correct, i
# End of StatementList()


# Function for R19.<Statement List Prime> ::=  <Statement List> | Epsilon
def StatementListPrime(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

    if (lexeme != "}") and (lexeme != "$$"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Statement List Prime> ::= <Statement List>")
        outputFile.write("     <Statement List Prime> ::= <Statement List>\n")
        i -= 1

        syntactic_correct, i = StatementList(lexer_table, i, lexeme, token, outputFile)

    else:
        print("     <Statement List Prime> ::= Epsilon")
        outputFile.write("     <Statement List Prime> ::= Epsilon\n")
        syntactic_correct = True
        i -= 1

    return syntactic_correct, i
# End of StatementListPrime()


# Function for R20. <Statement> ::=   <Compound>  |  <Assign>  |   <If>  |  <Return>   | <Print>   |   <Scan>   |  <While>
def Statement(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    # Compound
    if (lexeme == "{"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Statement> ::= <Compound>")
        outputFile.write("     <Statement> ::= <Compound>\n")
        syntactic_correct, i = Compound(lexer_table, i, lexeme, token, outputFile)
    # Assign
    elif (token == "Identifier"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Statement> ::= <Assign>")
        outputFile.write("     <Statement> ::= <Assign>\n")
        syntactic_correct, i = Assign(lexer_table, i, lexeme, token, outputFile)
    # If
    elif (lexeme == "if"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Statement> ::= <If>")
        outputFile.write("     <Statement> ::= <If>\n")
        syntactic_correct, i = If(lexer_table, i, lexeme, token, outputFile)
    # Return
    elif (lexeme == "return"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Statement> ::= <Return>")
        outputFile.write("     <Statement> ::= <Return>\n")
        syntactic_correct, i = Return(lexer_table, i, lexeme, token, outputFile)
    # Print
    elif (lexeme == "put"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Statement> ::= <Print>")
        outputFile.write("     <Statement> ::= <Print>\n")
        syntactic_correct, i = Print(lexer_table, i, lexeme, token, outputFile)
    # Scan
    elif (lexeme == "get"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Statement> ::= <Scan>")
        outputFile.write("     <Statement> ::= <Scan>\n")
        syntactic_correct, i = Scan(lexer_table, i, lexeme, token, outputFile)
    # While
    elif (lexeme == "while"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Statement> ::= <While>")
        outputFile.write("     <Statement> ::= <While>\n")
        syntactic_correct, i = While(lexer_table, i, lexeme, token, outputFile)
    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Invalid Statement.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Statement()

# Function for R21.<Compound> ::=   {  <Statement List>  }
def Compound(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    if (lexeme == "{"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        syntactic_correct, i = StatementList(lexer_table, i, lexeme, token, outputFile)
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
        if (lexeme == "}"):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            print("     <Compound> ::= {<Statement List>}")
            outputFile.write("     <Compound> ::= {<Statement List>}\n")

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '}'.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '{'.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Compound()

# Function for R22. <Assign> ::=     <Identifier> = <Expression> ;
def Assign(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    if (token == "Identifier"):

        save = lexeme
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        if (lexeme == "="):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)

            # Generate Assembly
            generate_assembly_instruction("POPM", get_memory_address(save))

            line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

            if (lexeme == ";"):
                print("Token: " + token + " --- Lexeme: " + lexeme)
                outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                print("     <Assign> ::= <Identifier> := <Expression);")
                outputFile.write("     <Assign> ::= <Identifier> := <Expression);\n")

            else:
                error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ';'.\n"
                print(error_string)
                outputFile.write(error_string)
                print("Program terminated")
                terminate()

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '='.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()

    return syntactic_correct, i
# End of Assign()

# Function for R23. <If> ::=     if  ( <Condition>  ) <Statement>   endif    |
#                          if  ( <Condition>  ) <Statement>   else  <Statement>  endif   
def If(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    if (lexeme == "if"):
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        # Generate Assembly
        address = instruction_table_address - 1

        if (lexeme == "("):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            syntactic_correct, i = Condition(lexer_table, i, lexeme, token, outputFile)
            line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
            if (lexeme == ")"):
                print("Token: " + token + " --- Lexeme: " + lexeme)
                outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                syntactic_correct, i = Statement(lexer_table, i, lexeme, token, outputFile)
                syntactic_correct, i = Else(lexer_table, i, lexeme, token, outputFile)

                # Generate Assembly
                back_patch(instruction_table_address)
            else:
                error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ')'.\n"
                print(error_string)
                outputFile.write(error_string)
                print("Program terminated")
                terminate()

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '('.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()

    return syntactic_correct, i
# End of If()

# Function for Else part of If()
def Else(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

    if (lexeme == "else"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        syntactic_correct, i = Statement(lexer_table, i, lexeme, token, outputFile)
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        if (lexeme == "endif"):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            print("     <If> ::= (<Condition>) <Statement> else <Statement> endif")
            outputFile.write("     <If> ::= (<Condition>) <Statement> else <Statement> endif\n")

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing endif.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()

    elif (lexeme == "endif"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <If> ::= (<Condition>) <Statement> endif")
        outputFile.write("     <If> ::= (<Condition>) <Statement> endif\n")

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing endif or else.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Else()

# Function for R24. <Return> ::=  return ; |  return <Expression> ;
def Return(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    if (lexeme == "return"):
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        if (lexeme == ";"):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            print("     <Return> ::= return;")
            outputFile.write("     <Return> ::= return;\n")

        else:
            i -= 1
            syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)
            line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

            if (lexeme == ";"):
                print("Token: " + token + " --- Lexeme: " + lexeme)
                outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                print("     <Return> ::= return <Expression>;")
                outputFile.write("     <Return> ::= return <Expression>;\n")

            else:
                error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ';'.\n"
                print(error_string)
                outputFile.write(error_string)
                print("Program terminated")
                terminate()

    return syntactic_correct, i
# End of Return()

# Function for R25. <Print> ::=    put ( <Expression>);
def Print(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    if (lexeme == "put"):
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
        if (lexeme == "("):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')

            syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)

            # Generate Assembly
            generate_assembly_instruction("STDOUT", None)

            line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

            if (lexeme == ")"):
                print("Token: " + token + " --- Lexeme: " + lexeme)
                outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

                if (lexeme == ";"):
                    print("Token: " + token + " --- Lexeme: " + lexeme)
                    outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                    print("     <Write> ::= put(<Expression>);")
                    outputFile.write("     <Write> ::= put(<Expression>);\n")

                else:
                    error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ';'.\n"
                    print(error_string)
                    outputFile.write(error_string)
                    print("Program terminated")
                    terminate()

            else:
                error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ')'.\n"
                print(error_string)
                outputFile.write(error_string)
                print("Program terminated")
                terminate()

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '('.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()
    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing 'put'.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Print()


# Function for R26.<Scan> ::=    get ( <IDs> );
def Scan(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    if (lexeme == "get"):
        # Generate Assembly
        generate_assembly_instruction("STDIN", None)

        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        if (lexeme == "("):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')

            line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
            i -= 1
            save = lexeme

            syntactic_correct, i = IDs(lexer_table, i, lexeme, token, outputFile)

            # Generate Assembly
            generate_assembly_instruction("POPM", get_memory_address(lexeme))

            line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

            if (lexeme == ")"):
                print("Token: " + token + " --- Lexeme: " + lexeme)
                outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

                if (lexeme == ";"):
                    print("Token: " + token + " --- Lexeme: " + lexeme)
                    outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                    print("     <Read> ::= read(<Statement List>);")
                    outputFile.write("     <Read> ::= read(<Statement List>);\n")

                else:
                    error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ';'.\n"
                    print(error_string)
                    outputFile.write(error_string)
                    print("Program terminated")
                    terminate()

            else:
                error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ')'.\n"
                print(error_string)
                outputFile.write(error_string)
                print("Program terminated")
                terminate()

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '('.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing 'get'.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Scan()


# Function for R27.<While> ::=  while ( <Condition>  )  <Statement>
def While(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    if (lexeme == "while"):
        # Generate Assembly
        address = instruction_table_address
        generate_assembly_instruction("LABEL", None)

        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        if (lexeme == "("):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            syntactic_correct, i = Condition(lexer_table, i, lexeme, token, outputFile)
            line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
            if (lexeme == ")"):
                print("Token: " + token + " --- Lexeme: " + lexeme)
                outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
                syntactic_correct, i = Statement(lexer_table, i, lexeme, token, outputFile)
                print("     <While> ::= while(<Condition>) Statement")
                outputFile.write("     <While> ::= while(<Condition>) Statement\n")

                # Generate Assembly
                generate_assembly_instruction("JUMP", address + 1)
                back_patch(instruction_table_address)
            else:
                error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ')'.\n"
                print(error_string)
                outputFile.write(error_string)
                print("Program terminated")
                terminate()

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing '('.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()

    return syntactic_correct, i
# End of While

# Function for R28.<Condition> ::=     <Expression>  <Relop>   <Expression>
def Condition(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)
    lexeme, syntactic_correct, i = Relop(lexer_table, i, lexeme, token, outputFile)
    syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)


    # Generate Assembly
    if (lexeme == "=="):
        generate_assembly_instruction("EQU", None)
        Jump_Stack.push(instruction_table_address)

    elif (lexeme == "^="):
        generate_assembly_instruction("NEQ", None)
        Jump_Stack.push(instruction_table_address)

    elif (lexeme == ">"):
        generate_assembly_instruction("GRT", None)
        Jump_Stack.push(instruction_table_address)

    elif (lexeme == "<"):
        generate_assembly_instruction("LES", None)
        Jump_Stack.push(instruction_table_address)

    elif (lexeme == "=>"):
        generate_assembly_instruction("GEQ", None)
        Jump_Stack.push(instruction_table_address)

    elif (lexeme == "=<"):
        generate_assembly_instruction("LEQ", None)
        Jump_Stack.push(instruction_table_address)

    # Generate Assembly
    generate_assembly_instruction("JUMPZ", None)

    return syntactic_correct, i
# End of Condition

# Function for R29.<Relop> ::=        ==   |   ^=    |   >     |   <    |   =>    |   =<
def Relop(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

    if (lexeme == "=="):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Expression> = <Expression>")
        outputFile.write("     <Expression> = <Expression>\n")

    elif (lexeme == "^="):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Expression> ^= <Expression>")
        outputFile.write("     <Expression> => <Expression>\n")

    elif (lexeme == ">"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Expression> > <Expression>")
        outputFile.write("     <Expression> > <Expression>\n")

    elif (lexeme == "<"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Expression> < <Expression>")
        outputFile.write("     <Expression> < <Expression>\n")

    elif (lexeme == "=>"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Expression> => <Expression>")
        outputFile.write("     <Expression> <= <Expression>\n")

    elif (lexeme == "=<"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Expression> =< <Expression>")
        outputFile.write("     <Expression> <= <Expression>\n")

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Invalid Operator" + lexeme + ".\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return lexeme, syntactic_correct, i
# End of Relop

# Function for R30. <Expression> := <Term> <Expression Prime>
def Expression(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    syntactic_correct, i = Term(lexer_table, i, lexeme, token, outputFile)
    syntactic_correct, i = ExpressionPrime(lexer_table, i, lexeme, token, outputFile)

    return syntactic_correct, i
# End of Expression

# Function for R31. <Expression Prime>:= + <Term> <Expression Prime>| - <Term> <Expression Prime> | <Term> | Epsilon
def ExpressionPrime(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (lexeme == "+"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Expression Prime> = + <Expression>")
        outputFile.write("     <Expression Prime> = + <Expression>\n")

        syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)

        # Generate Assembly
        generate_assembly_instruction("ADD", None)

    elif (lexeme == "-"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Expression Prime> = - <Expression>")
        outputFile.write("     <Expression Prime> = - <Expression>\n")

        syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)

        # Generate Assembly
        generate_assembly_instruction("SUB", None)
    else:
        i -= 1
        print("     <Expression Prime> = Epsilon")
        outputFile.write("     <Expression Prime> = Epsilon")

    return syntactic_correct, i
# End of ExpressionPrime()

# Function fir R32. <Term>    ::=  <Factor> <Term Prime>
def Term(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    print("     <Term> = <Factor><Term Prime>")
    outputFile.write("    <Term> = <Factor><Term Prime>\n")
    syntactic_correct, i = Factor(lexer_table, i, lexeme, token, outputFile)
    syntactic_correct, i = TermPrime(lexer_table, i, lexeme, token, outputFile)

    return syntactic_correct, i
# End of Term()

# Function for R33. <Term Prime> := *<Factor><Term Prime> |/<Factor> <Term Prime>| <Factor> | Epsilon
def TermPrime(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False

    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (lexeme == "*"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Term Prime> = * <Factor><Term>\n")
        outputFile.write("     <Term Prime> = * <Factor><Term>\n")

        syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)

        # Generate Assembly
        generate_assembly_instruction("MUL", None)

    elif (lexeme == "/"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Term Prime> = / <Factor><Term>\n")
        outputFile.write("     <Term Prime> = / <Factor><Term>\n")

        syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)

        # Generate Assembly
        generate_assembly_instruction("DIV", None)

    else:
        i -= 1
        print("     <Term Prime> = Epsilon")
        outputFile.write("     <Term Prime> = Epsilon\n")

    return syntactic_correct, i
# End of TermPrime()

# Function for R34. <Factor> ::=      -  <Primary>    |    <Primary>
def Factor(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (lexeme == "-"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Factor> = - <Primary>")
        outputFile.write("     <Factor> = - <Primary>\n")

    else:
        i -= 1
        print("     <Factor> = <Primary>")
        outputFile.write("     <Factor> = <Primary>\n")

    syntactic_correct, i = Primary(lexer_table, i, lexeme, token, outputFile)

    return syntactic_correct, i
# End of Factor()


# Function for R35.<Primary> ::=     <Identifier>  |  <Integer>  |   <Identifier>  ( <IDs> )   |   ( <Expression> )   |
#                                     <Real>  |   true   |  false
def Primary(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    if (token == "Identifier"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Primary> = <Identifier>")
        outputFile.write("     <Primary> = <Identifier>\n")

        # Generate Assembly
        generate_assembly_instruction("PUSHM", get_memory_address(lexeme))

        syntactic_correct, i = PrimaryPrime(lexer_table, i, lexeme, token, outputFile)

    elif (token == "Integer"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Primary> = <Integer>\n")
        outputFile.write("     <Primary> = <Integer>\n")

        # Generate Assembly
        generate_assembly_instruction("PUSHI", lexeme)
    elif (token == "Real"):
        print ("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print ("     <Primary> = <Real>")
        outputFile.write("     <Primary> = <Real>\n")

    elif (lexeme == "true"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Primary> = true")
        outputFile.write("     <Primary> = true\n")

        # Generate Assembly
        generate_assembly_instruction("PUSHI", 1)

    elif (lexeme == "false"):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        print("     <Primary> = false")
        outputFile.write("     <Primary> = false\n")

        # Generate Assembly
        generate_assembly_instruction("PUSHI", 0)

    elif (lexeme == "("):
        print("Token: " + token + " --- Lexeme: " + lexeme)
        outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
        syntactic_correct, i = Expression(lexer_table, i, lexeme, token, outputFile)
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        if (lexeme == ")"):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            print("     <Primary> = (<Expression>)")
            outputFile.write("     <Primary> = (<Expression>)\n")

        else:
            error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Missing ')'.\n"
            print(error_string)
            outputFile.write(error_string)
            print("Program terminated")
            terminate()

    else:
        error_string = "[Line Number:" + line_number + "]=" + "Syntax Error: Invalid token.\n"
        print(error_string)
        outputFile.write(error_string)
        print("Program terminated")
        terminate()

    return syntactic_correct, i
# End of Primary()

# Function for R35. <PrimaryPrime>
def PrimaryPrime(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    print("Token: " + token + " --- Lexeme: " + lexeme)
    outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
    if (lexeme == "("):
        syntactic_correct, i = IDs(lexer_table, i, lexeme, token, outputFile)
        line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)

        if (lexeme == ")"):
            print("Token: " + token + " --- Lexeme: " + lexeme)
            outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
            print("     <Primary Prime> = [<IDs>]")
            outputFile.write("     <Primary Prime> = [<IDs>])\n")

    else:
        i -= 1
        print("     <Primary Prime> = Epsilon")
        outputFile.write("     <Primary Prime> = Epsilon\n")

    return syntactic_correct, i
# End of PrimaryPrime

# Function for R36.<Empty>   ::= Epsilon
def Empty(lexer_table, i, lexeme, token, outputFile):
    syntactic_correct = False
    #     line_number, token, lexeme, i = next_lexeme(lexer_table, i + 1)
    print("Token: " + token + " --- Lexeme: " + lexeme)
    outputFile.write("Token: " + token + " --- Lexeme: " + lexeme + '\n')
    print("     <Empty> ::= Epsilon")
    outputFile.write("     <Empty> ::= Epsilon\n")
    syntactic_correct = True

    return syntactic_correct, i
# End of Empty


# Function to get the lexer table
def get_lexer_table():
    global input_filename
    # run lexer
    input_filename = lexer.main()

    # Read lexer output file generated by lexer.py
    lexer_output_file = open(input_filename + "_lexer_output" + ".txt", "r")
    lexer_table = lexer_output_file.readlines()
    output_file = open(input_filename + "_syntax_output" + ".txt", "w")
    return lexer_table
# End of get_lexer_table()

def main():
    # Get Lexer Table file
    lexer_table_content = get_lexer_table()
    # Generate Syntax
    simplified_RAT18S(lexer_table_content)


if __name__ == "__main__":
    main()
